package demo02;

/**
 * 
 * @author 12057
 * 
 * 步骤2：创建测试类，测试调用父类静态变量
 * 
 * 测试：子类调用父类静态成员，是否对子类进行加载和初始化
 * 
 * 
 * 加载:通过类的全限定名来获取定义此类的二进制字节流，将内部静态结构转为方法去的运行是数据结
 * 构，并在堆中生成一个java.lang.Class对象。Java虚拟机不会无条件装载Class类型，必
 * 须要求类或者接口必须是主动引用，才能被装载。
 * 	1.当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。
 * 	2.当调用类的静态方法时，即当使用了字节码invokestatic指令。
 * 	3.当实用类或者接口的静态字段时(final常量除外),比如，使用getstatic指令。
 * 	4.当是哦那个java.lang.reflect包中的方法反射类的方法时。
 * 	5.当初始化子类时，要求先初始化父类。
 * 	6.作为启动虚拟机，含有main()方法的哪个类
 * 除了以上的情况属于主动使用，其他的情况均属于被动使用。被动使用不会引起类的初始化
 * 
 * 连接:将已读入的内存的热禁止数据合并到JVM运行环境中
 * 初始化:JVM会按照初始化语句在类文件中的先后顺序执行
 * 
 * 步骤三:在VM option中添加java命令执行可以实现追踪类加载过程信息的参数
 * -xx:+TraceClassLoading
 * 
 * 总结：
 * 	1.通过new关键字创建类的实例会加载相关类，首先加载Father类，再加载Son类
 * 	2.再初始化子类的时候，首先先初始化父类
 */
public class LoaderFatherTest {

	public static void main(String[] args) {
		Son son = new Son();
	}

}
